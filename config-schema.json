{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://github.com/filecoin-project/curio/deps/config/curio-config",
  "$ref": "#/$defs/CurioConfig",
  "$defs": {
    "ApisConfig": {
      "properties": {
        "ChainApiInfo": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "ChainApiInfo is the API endpoint for the Lotus daemon."
          }
        },
        "StorageRPCSecret": {
          "type": "string",
          "options": {
            "infoText": "API auth secret for the Curio nodes to use. This value should only be set on the bade layer."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "BalanceManagerConfig": {
      "properties": {
        "MK12Collateral": {
          "$ref": "#/$defs/MK12CollateralConfig",
          "options": {
            "infoText": "MK12Collateral defines the configuration for managing collateral and related balance thresholds in the miner's market."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "BatchFeeConfig": {
      "properties": {
        "Base": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "Accepts a decimal string (e.g., \"123.45\") with optional \"fil\" or \"attofil\" suffix."
          }
        },
        "PerSector": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "Accepts a decimal string (e.g., \"123.45\") with optional \"fil\" or \"attofil\" suffix."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CommitBatchingConfig": {
      "properties": {
        "BaseFeeThreshold": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "Base fee value below which we should try to send Commit messages immediately\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"0.005 FIL\")"
          }
        },
        "Timeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Maximum amount of time any given sector in the batch can wait for the batch to accumulate\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"1h0m0s\")"
          }
        },
        "Slack": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Time buffer for forceful batch submission before sectors/deals in batch would start expiring\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"1h0m0s\")"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CompressionConfig": {
      "properties": {
        "GzipLevel": { "type": "integer" },
        "BrotliLevel": { "type": "integer" },
        "DeflateLevel": { "type": "integer" }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioAddresses": {
      "properties": {
        "PreCommitControl": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "PreCommitControl is an array of Addresses to send PreCommit messages from"
          }
        },
        "CommitControl": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "CommitControl is an array of Addresses to send Commit messages from"
          }
        },
        "DealPublishControl": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "DealPublishControl is an array of Address to send the deal collateral from with PublishStorageDeal Message"
          }
        },
        "TerminateControl": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "TerminateControl is a list of addresses used to send Terminate messages."
          }
        },
        "DisableOwnerFallback": {
          "type": "boolean",
          "options": {
            "infoText": "DisableOwnerFallback disables usage of the owner address for messages\nsent automatically"
          }
        },
        "DisableWorkerFallback": {
          "type": "boolean",
          "options": {
            "infoText": "DisableWorkerFallback disables usage of the worker address for messages\nsent automatically, if control addresses are configured.\nA control address that doesn't have enough funds will still be chosen\nover the worker address if this flag is set."
          }
        },
        "MinerAddresses": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "MinerAddresses are the addresses of the miner actors"
          }
        },
        "BalanceManager": {
          "$ref": "#/$defs/BalanceManagerConfig",
          "options": {
            "infoText": "BalanceManagerConfig specifies the configuration parameters for managing wallet balances and actor-related funds,\nincluding collateral and other operational resources."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioAlertingConfig": {
      "properties": {
        "MinimumWalletBalance": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "MinimumWalletBalance is the minimum balance all active wallets. If the balance is below this value, an\nalerts will be triggered for the wallet\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"5 FIL\")"
          }
        },
        "PagerDuty": {
          "$ref": "#/$defs/PagerDutyConfig",
          "options": {
            "infoText": "PagerDutyConfig is the configuration for the PagerDuty alerting integration."
          }
        },
        "PrometheusAlertManager": {
          "$ref": "#/$defs/PrometheusAlertManagerConfig",
          "options": {
            "infoText": "PrometheusAlertManagerConfig is the configuration for the Prometheus AlertManager alerting integration."
          }
        },
        "SlackWebhook": {
          "$ref": "#/$defs/SlackWebhookConfig",
          "options": {
            "infoText": "SlackWebhookConfig is a configuration type for Slack webhook integration."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioBatchingConfig": {
      "properties": {
        "PreCommit": {
          "$ref": "#/$defs/PreCommitBatchingConfig",
          "options": { "infoText": "Precommit Batching configuration" }
        },
        "Commit": {
          "$ref": "#/$defs/CommitBatchingConfig",
          "options": { "infoText": "Commit batching configuration" }
        },
        "Update": {
          "$ref": "#/$defs/UpdateBatchingConfig",
          "options": { "infoText": "Snap Deals batching configuration" }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioConfig": {
      "properties": {
        "Subsystems": {
          "$ref": "#/$defs/CurioSubsystemsConfig",
          "options": {
            "infoText": "Subsystems defines configuration settings for various subsystems within the Curio node."
          }
        },
        "Fees": {
          "$ref": "#/$defs/CurioFees",
          "options": {
            "infoText": "Fees holds the fee-related configuration parameters for various operations in the Curio node."
          }
        },
        "Addresses": {
          "items": { "$ref": "#/$defs/CurioAddresses" },
          "type": "array",
          "options": {
            "infoText": "Addresses specifies the list of miner addresses and their related wallet addresses."
          }
        },
        "Proving": {
          "$ref": "#/$defs/CurioProvingConfig",
          "options": {
            "infoText": "Proving defines the configuration settings related to proving functionality within the Curio node."
          }
        },
        "HTTP": {
          "$ref": "#/$defs/HTTPConfig",
          "options": {
            "infoText": "HTTP represents the configuration for the HTTP server settings in the Curio node."
          }
        },
        "Market": {
          "$ref": "#/$defs/MarketConfig",
          "options": {
            "infoText": "Market specifies configuration options for the Market subsystem within the Curio node."
          }
        },
        "Ingest": {
          "$ref": "#/$defs/CurioIngestConfig",
          "options": {
            "infoText": "Ingest defines configuration parameters for handling and limiting deal ingestion pipelines within the Curio node."
          }
        },
        "Seal": {
          "$ref": "#/$defs/CurioSealConfig",
          "options": {
            "infoText": "Seal defines the configuration related to the sealing process in Curio."
          }
        },
        "Apis": {
          "$ref": "#/$defs/ApisConfig",
          "options": {
            "infoText": "Apis defines the configuration for API-related settings in the Curio system."
          }
        },
        "Alerting": {
          "$ref": "#/$defs/CurioAlertingConfig",
          "options": {
            "infoText": "Alerting specifies configuration settings for alerting mechanisms, including thresholds and external integrations."
          }
        },
        "Batching": {
          "$ref": "#/$defs/CurioBatchingConfig",
          "options": {
            "infoText": "Batching represents the batching configuration for pre-commit, commit, and update operations."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioFees": {
      "properties": {
        "MaxPreCommitBatchGasFee": {
          "$ref": "#/$defs/BatchFeeConfig",
          "options": {
            "infoText": "maxBatchFee = maxBase + maxPerSector * nSectors\n(Default: #Base = \"0 FIL\" and #PerSector = \"0.02 FIL\")"
          }
        },
        "MaxCommitBatchGasFee": {
          "$ref": "#/$defs/BatchFeeConfig",
          "options": {
            "infoText": "maxBatchFee = maxBase + maxPerSector * nSectors\n(Default: #Base = \"0 FIL\" and #PerSector = \"0.03 FIL\")"
          }
        },
        "MaxUpdateBatchGasFee": {
          "$ref": "#/$defs/BatchFeeConfig",
          "options": {
            "infoText": "Accepts a decimal string (e.g., \"123.45\") with optional \"fil\" or \"attofil\" suffix.\n(Default: #Base = \"0 FIL\" and #PerSector = \"0.03 FIL\")"
          }
        },
        "MaxWindowPoStGasFee": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "WindowPoSt is a high-value operation, so the default fee should be high.\nAccepts a decimal string (e.g., \"123.45\") with optional \"fil\" or \"attofil\" suffix. (Default: \"5 fil\")"
          }
        },
        "CollateralFromMinerBalance": {
          "type": "boolean",
          "options": {
            "infoText": "Whether to use available miner balance for sector collateral instead of sending it with each message (Default: false)"
          }
        },
        "DisableCollateralFallback": {
          "type": "boolean",
          "options": {
            "infoText": "Don't send collateral with messages even if there is no available balance in the miner actor (Default: false)"
          }
        },
        "MaximizeFeeCap": {
          "type": "boolean",
          "options": {
            "infoText": "MaximizeFeeCap makes the sender set maximum allowed FeeCap on all sent messages.\nThis generally doesn't increase message cost, but in highly congested network messages\nare much less likely to get stuck in mempool. (Default: true)"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioIngestConfig": {
      "properties": {
        "MaxMarketRunningPipelines": {
          "type": "integer",
          "options": {
            "infoText": "MaxMarketRunningPipelines is the maximum number of market pipelines that can be actively running tasks.\nA \"running\" pipeline is one that has at least one task currently assigned to a machine (owner_id is not null).\nIf this limit is exceeded, the system will apply backpressure to delay processing of new deals.\n0 means unlimited. (Default: 64)"
          }
        },
        "MaxQueueDownload": {
          "type": "integer",
          "options": {
            "infoText": "MaxQueueDownload is the maximum number of pipelines that can be queued at the downloading stage,\nwaiting for a machine to pick up their task (owner_id is null).\nIf this limit is exceeded, the system will apply backpressure to slow the ingestion of new deals.\n0 means unlimited. (Default: 8)"
          }
        },
        "MaxQueueCommP": {
          "type": "integer",
          "options": {
            "infoText": "MaxQueueCommP is the maximum number of pipelines that can be queued at the CommP (verify) stage,\nwaiting for a machine to pick up their verification task (owner_id is null).\nIf this limit is exceeded, the system will apply backpressure, delaying new deal processing.\n0 means unlimited. (Default: 8)"
          }
        },
        "MaxQueueDealSector": {
          "type": "integer",
          "options": {
            "infoText": "Maximum number of sectors that can be queued waiting for deals to start processing.\n0 = unlimited\nNote: This mechanism will delay taking deal data from markets, providing backpressure to the market subsystem.\nThe DealSector queue includes deals that are ready to enter the sealing pipeline but are not yet part of it.\nDealSector queue is the first queue in the sealing pipeline, making it the primary backpressure mechanism. (Default: 8)"
          }
        },
        "MaxQueueSDR": {
          "type": "integer",
          "options": {
            "infoText": "Maximum number of sectors that can be queued waiting for SDR to start processing.\n0 = unlimited\nNote: This mechanism will delay taking deal data from markets, providing backpressure to the market subsystem.\nThe SDR queue includes deals which are in the process of entering the sealing pipeline. In case of the SDR tasks it is\npossible that this queue grows more than this limit(CC sectors), the backpressure is only applied to sectors\nentering the pipeline.\nOnly applies to PoRep pipeline (DoSnap = false) (Default: 8)"
          }
        },
        "MaxQueueTrees": {
          "type": "integer",
          "options": {
            "infoText": "Maximum number of sectors that can be queued waiting for SDRTrees to start processing.\n0 = unlimited\nNote: This mechanism will delay taking deal data from markets, providing backpressure to the market subsystem.\nIn case of the trees tasks it is possible that this queue grows more than this limit, the backpressure is only\napplied to sectors entering the pipeline.\nOnly applies to PoRep pipeline (DoSnap = false) (Default: 0)"
          }
        },
        "MaxQueuePoRep": {
          "type": "integer",
          "options": {
            "infoText": "Maximum number of sectors that can be queued waiting for PoRep to start processing.\n0 = unlimited\nNote: This mechanism will delay taking deal data from markets, providing backpressure to the market subsystem.\nLike with the trees tasks, it is possible that this queue grows more than this limit, the backpressure is only\napplied to sectors entering the pipeline.\nOnly applies to PoRep pipeline (DoSnap = false) (Default: 0)"
          }
        },
        "MaxQueueSnapEncode": {
          "type": "integer",
          "options": {
            "infoText": "MaxQueueSnapEncode is the maximum number of sectors that can be queued waiting for UpdateEncode tasks to start.\n0 means unlimited.\nThis applies backpressure to the market subsystem by delaying the ingestion of deal data.\nOnly applies to the Snap Deals pipeline (DoSnap = true). (Default: 16)"
          }
        },
        "MaxQueueSnapProve": {
          "type": "integer",
          "options": {
            "infoText": "MaxQueueSnapProve is the maximum number of sectors that can be queued waiting for UpdateProve to start processing.\n0 means unlimited.\nThis applies backpressure in the Snap Deals pipeline (DoSnap = true) by delaying new deal ingestion. (Default: 0)"
          }
        },
        "MaxDealWaitTime": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Maximum time an open deal sector should wait for more deals before it starts sealing.\nThis ensures that sectors don't remain open indefinitely, consuming resources.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"1h0m0s\")"
          }
        },
        "DoSnap": {
          "type": "boolean",
          "options": {
            "infoText": "DoSnap, when set to true, enables snap deal processing for deals ingested by this instance.\nUnlike lotus-miner, there is no fallback to PoRep when no snap sectors are available.\nWhen enabled, all deals will be processed as snap deals. (Default: false)"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioProvingConfig": {
      "properties": {
        "ParallelCheckLimit": {
          "type": "integer",
          "options": {
            "infoText": "Maximum number of sector checks to run in parallel. (0 = unlimited)\n\nWARNING: Setting this value too high may make the node crash by running out of stack\nWARNING: Setting this value too low may make sector challenge reading much slower, resulting in failed PoSt due\nto late submission.\n\nAfter changing this option, confirm that the new value works in your setup by invoking\n'curio test wd task 0' (Default: 32)"
          }
        },
        "SingleCheckTimeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Maximum amount of time a proving pre-check can take for a sector. If the check times out the sector will be skipped\n\nWARNING: Setting this value too low risks in sectors being skipped even though they are accessible, just reading the\ntest challenge took longer than this timeout\nWARNING: Setting this value too high risks missing PoSt deadline in case IO operations related to this sector are\nblocked (e.g. in case of disconnected NFS mount)\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"10m0s\")"
          }
        },
        "PartitionCheckTimeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Maximum amount of time a proving pre-check can take for an entire partition. If the check times out, sectors in\nthe partition which didn't get checked on time will be skipped\n\nWARNING: Setting this value too low risks in sectors being skipped even though they are accessible, just reading the\ntest challenge took longer than this timeout\nWARNING: Setting this value too high risks missing PoSt deadline in case IO operations related to this partition are\nblocked or slow. Time duration string (e.g., \"1h2m3s\") in TOML format.  (Default: \"20m0s\")"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioSealConfig": {
      "properties": {
        "BatchSealSectorSize": {
          "type": "string",
          "options": {
            "infoText": "BatchSealSectorSize Allows setting the sector size supported by the batch seal task.\nCan be any value as long as it is \"32GiB\". (Default: \"32GiB\")"
          }
        },
        "BatchSealBatchSize": {
          "type": "integer",
          "options": {
            "infoText": "Number of sectors in a seal batch. Depends on hardware and supraseal configuration. (Default: 32)"
          }
        },
        "BatchSealPipelines": {
          "type": "integer",
          "options": {
            "infoText": "Number of parallel pipelines. Can be 1 or 2. Depends on available raw block storage (Default: 2)"
          }
        },
        "SingleHasherPerThread": {
          "type": "boolean",
          "options": {
            "infoText": "SingleHasherPerThread is a compatibility flag for older CPUs. Zen3 and later supports two sectors per thread.\nSet to false for older CPUs (Zen 2 and before). (Default: false)"
          }
        },
        "LayerNVMEDevices": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "LayerNVMEDevices OPTIONAL! A list of pcie device addresses that should be used for SDR layer storage.\nThe required storage is 11 * BatchSealBatchSize * BatchSealSectorSize * BatchSealPipelines\nTotal Read IOPS for optimal performance should be 10M+.\nThe devices MUST be NVMe devices, not used for anything else. Any data on the devices will be lost!\n\nIt's recommend to define these settings in a per-machine layer, as the devices are machine-specific.\n\nIf left empty a list will be inferred automatically from /sys/bus/pci/drivers/vfio-pci/... using all\ndevices with the NVMe I/O PCI class - 0x010802\n\nExample: [\"0000:01:00.0\", \"0000:01:00.1\"]"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "CurioSubsystemsConfig": {
      "properties": {
        "EnableWindowPost": {
          "type": "boolean",
          "options": {
            "infoText": "EnableWindowPost enables window post to be executed on this curio instance. Each machine in the cluster\nwith WindowPoSt enabled will also participate in the window post scheduler. It is possible to have multiple\nmachines with WindowPoSt enabled which will provide redundancy, and in case of multiple partitions per deadline,\nwill allow for parallel processing of partitions.\n\nIt is possible to have instances handling both WindowPoSt and WinningPoSt, which can provide redundancy without\nthe need for additional machines. In setups like this it is generally recommended to run\npartitionsPerDeadline+1 machines. (Default: false)"
          }
        },
        "WindowPostMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of WindowPostMaxTasks tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. We do not recommend setting this value and let system resources determine\nthe maximum tasks (Default: 0 - unlimited)"
          }
        },
        "EnableWinningPost": {
          "type": "boolean",
          "options": {
            "infoText": "EnableWinningPost enables winning post to be executed on this curio instance.\nEach machine in the cluster with WinningPoSt enabled will also participate in the winning post scheduler.\nIt is possible to mix machines with WindowPoSt and WinningPoSt enabled, for details see the EnableWindowPost\ndocumentation. (Default: false)"
          }
        },
        "WinningPostMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of WinningPostMaxTasks tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. We do not recommend setting this value and let system resources determine\nthe maximum tasks (Default: 0 - unlimited)"
          }
        },
        "EnableParkPiece": {
          "type": "boolean",
          "options": {
            "infoText": "EnableParkPiece enables the \"piece parking\" task to run on this node. This task is responsible for fetching\npieces from the network and storing them in the storage subsystem until sectors are sealed. This task is\nonly applicable when integrating with boost, and should be enabled on nodes which will hold deal data\nfrom boost until sectors containing the related pieces have the TreeD/TreeR constructed.\nNote that future Curio implementations will have a separate task type for fetching pieces from the internet. (Default: false)"
          }
        },
        "ParkPieceMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of ParkPieceMaxTasks tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine (Default: 0 - unlimited)"
          }
        },
        "EnableSealSDR": {
          "type": "boolean",
          "options": {
            "infoText": "EnableSealSDR enables SDR tasks to run. SDR is the long sequential computation\ncreating 11 layer files in sector cache directory.\n\nSDR is the first task in the sealing pipeline. It's inputs are just the hash of the\nunsealed data (CommD), sector number, miner id, and the seal proof type.\nIt's outputs are the 11 layer files in the sector cache directory.\n\nIn lotus-miner this was run as part of PreCommit1. (Default: false)"
          }
        },
        "SealSDRMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of SDR tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 0 - unlimited)"
          }
        },
        "SealSDRMinTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of SDR tasks that need to be queued before the system will start accepting new tasks.\nThe main purpose of this setting is to allow for enough tasks to accumulate for batch sealing. When batch sealing\nnodes are present in the cluster, this value should be set to batch_size+1 to allow for the batch sealing node to\nfill up the batch.\nThis setting can also be used to give priority to other nodes in the cluster by setting this value to a higher\nvalue on the nodes which should have less priority. (Default: 0 - unlimited)"
          }
        },
        "EnableSealSDRTrees": {
          "type": "boolean",
          "options": {
            "infoText": "EnableSealSDRTrees enables the SDR pipeline tree-building task to run.\nThis task handles encoding of unsealed data into last sdr layer and building\nof TreeR, TreeC and TreeD.\n\nThis task runs after SDR\nTreeD is first computed with optional input of unsealed data\nTreeR is computed from replica, which is first computed as field\naddition of the last SDR layer and the bottom layer of TreeD (which is the unsealed data)\nTreeC is computed from the 11 SDR layers\nThe 3 trees will later be used to compute the PoRep proof.\n\nIn case of SyntheticPoRep challenges for PoRep will be pre-generated at this step, and trees and layers\nwill be dropped. SyntheticPoRep works by pre-generating a very large set of challenges (~30GiB on disk)\nthen using a small subset of them for the actual PoRep computation. This allows for significant scratch space\nsaving between PreCommit and PoRep generation at the expense of more computation (generating challenges in this step)\n\nIn lotus-miner this was run as part of PreCommit2 (TreeD was run in PreCommit1).\nNote that nodes with SDRTrees enabled will also answer to Finalize tasks,\nwhich just remove unneeded tree data after PoRep is computed. (Default: false)"
          }
        },
        "SealSDRTreesMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of SealSDRTrees tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 0 - unlimited)"
          }
        },
        "FinalizeMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "FinalizeMaxTasks is the maximum amount of finalize tasks that can run simultaneously.\nThe finalize task is enabled on all machines which also handle SDRTrees tasks. Finalize ALWAYS runs on whichever\nmachine holds sector cache files, as it removes unneeded tree data after PoRep is computed.\nFinalize will run in parallel with the SubmitCommitMsg task. (Default: 0 - unlimited)"
          }
        },
        "EnableSendPrecommitMsg": {
          "type": "boolean",
          "options": {
            "infoText": "EnableSendPrecommitMsg enables the sending of precommit messages to the chain\nfrom this curio instance.\nThis runs after SDRTrees and uses the output CommD / CommR (roots of TreeD / TreeR) for the message (Default: false)"
          }
        },
        "EnablePoRepProof": {
          "type": "boolean",
          "options": {
            "infoText": "EnablePoRepProof enables the computation of the porep proof\n\nThis task runs after interactive-porep seed becomes available, which happens 150 epochs (75min) after the\nprecommit message lands on chain. This task should run on a machine with a GPU. Vanilla PoRep proofs are\nrequested from the machine which holds sector cache files which most likely is the machine which ran the SDRTrees\ntask.\n\nIn lotus-miner this was Commit1 / Commit2 (Default: false)"
          }
        },
        "PoRepProofMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of PoRepProof tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 0 - unlimited)"
          }
        },
        "EnableSendCommitMsg": {
          "type": "boolean",
          "options": {
            "infoText": "EnableSendCommitMsg enables the sending of commit messages to the chain\nfrom this curio instance. (Default: false)"
          }
        },
        "RequireActivationSuccess": {
          "type": "boolean",
          "options": {
            "infoText": "Whether to abort if any sector activation in a batch fails (newly sealed sectors, only with ProveCommitSectors3). (Default: true)"
          }
        },
        "RequireNotificationSuccess": {
          "type": "boolean",
          "options": {
            "infoText": "Whether to abort if any sector activation in a batch fails (updating sectors, only with ProveReplicaUpdates3). (Default: true)"
          }
        },
        "EnableMoveStorage": {
          "type": "boolean",
          "options": {
            "infoText": "EnableMoveStorage enables the move-into-long-term-storage task to run on this curio instance.\nThis tasks should only be enabled on nodes with long-term storage.\n\nThe MoveStorage task is the last task in the sealing pipeline. It moves the sealed sector data from the\nSDRTrees machine into long-term storage. This task runs after the Finalize task. (Default: false)"
          }
        },
        "NoUnsealedDecode": {
          "type": "boolean",
          "options": {
            "infoText": "NoUnsealedDecode disables the decoding sector data on this node. Normally data encoding is enabled by default on\nstorage nodes with the MoveStorage task enabled. Setting this option to true means that unsealed data for sectors\nwill not be stored on this node (Default: false)"
          }
        },
        "MoveStorageMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of MoveStorage tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. It is recommended that this value is set to a number which\nuses all available network (or disk) bandwidth on the machine without causing bottlenecks. NOTE: unlike most other\ntasks, when this value is set the maximum number of concurrent tasks will not be bounded by CPU core count (Default: 0 - unlimited)"
          }
        },
        "EnableUpdateEncode": {
          "type": "boolean",
          "options": {
            "infoText": "EnableUpdateEncode enables the encoding step of the SnapDeal process on this curio instance.\nThis step involves encoding the data into the sector and computing updated TreeR (uses gpu). (Default: false)"
          }
        },
        "EnableUpdateProve": {
          "type": "boolean",
          "options": {
            "infoText": "EnableUpdateProve enables the proving step of the SnapDeal process on this curio instance.\nThis step generates the snark proof for the updated sector. (Default: false)"
          }
        },
        "EnableUpdateSubmit": {
          "type": "boolean",
          "options": {
            "infoText": "EnableUpdateSubmit enables the submission of SnapDeal proofs to the blockchain from this curio instance.\nThis step submits the generated proofs to the chain. (Default: false)"
          }
        },
        "UpdateEncodeMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "UpdateEncodeMaxTasks sets the maximum number of concurrent SnapDeal encoding tasks that can run on this instance. (Default: 0 - unlimited)"
          }
        },
        "UpdateProveMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "UpdateProveMaxTasks sets the maximum number of concurrent SnapDeal proving tasks that can run on this instance. (Default: 0 - unlimited)"
          }
        },
        "EnableWebGui": {
          "type": "boolean",
          "options": {
            "infoText": "EnableWebGui enables the web GUI on this curio instance. The UI has minimal local overhead, but it should\nonly need to be run on a single machine in the cluster. (Default: false)"
          }
        },
        "GuiAddress": {
          "type": "string",
          "options": {
            "infoText": "The address that should listen for Web GUI requests. It should be in form \"x.x.x.x:1234\" (Default: 0.0.0.0:4701)"
          }
        },
        "UseSyntheticPoRep": {
          "type": "boolean",
          "options": {
            "infoText": "UseSyntheticPoRep enables the synthetic PoRep for all new sectors. When set to true, will reduce the amount of\ncache data held on disk after the completion of TreeRC task to 11GiB. (Default: false)"
          }
        },
        "SyntheticPoRepMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of SyntheticPoRep tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 0 - unlimited)"
          }
        },
        "EnableBatchSeal": {
          "type": "boolean",
          "options": {
            "infoText": "EnableBatchSeal enabled SupraSeal batch sealing on the node.  (Default: false)"
          }
        },
        "EnableDealMarket": {
          "type": "boolean",
          "options": {
            "infoText": "EnableDealMarket enabled the deal market on the node. This would also enable libp2p on the node, if configured. (Default: false)"
          }
        },
        "EnablePDP": {
          "type": "boolean",
          "options": {
            "infoText": "Enable handling for PDP (proof-of-data possession) deals / proving on this node.\nPDP deals allow the node to directly store and prove unsealed data with \"PDP Services\" like Storacha.\nThis feature is BETA and should only be enabled on nodes which are part of a PDP network."
          }
        },
        "EnableCommP": {
          "type": "boolean",
          "options": {
            "infoText": "EnableCommP enables the commP task on te node. CommP is calculated before sending PublishDealMessage for a Mk12 deal\nMust have EnableDealMarket = True (Default: false)"
          }
        },
        "CommPMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of CommP tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 0 - unlimited)"
          }
        },
        "IndexingMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of indexing and IPNI tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 8)"
          }
        },
        "EnableBalanceManager": {
          "type": "boolean",
          "options": {
            "infoText": "EnableBalanceManager enables the task to automatically manage the market balance of the miner's market actor (Default: false)"
          }
        },
        "BindSDRTreeToNode": {
          "type": "boolean",
          "options": {
            "infoText": "BindSDRTreeToNode forces the TreeD and TreeRC tasks to be executed on the same node where SDR task was executed\nfor the sector. Please ensure that TreeD and TreeRC task are enabled and relevant resources are available before\nenabling this option. (Default: false)"
          }
        },
        "EnableProofShare": {
          "type": "boolean",
          "options": {
            "infoText": "EnableProofShare enables the ProofShare tasks on the node. This subsystem will request proof work from a marketplace\nwhenever local machine can take on more Snark work. ProofShare tasks have priority over local snark tasks, but new\nProofShare work will only be requested if there is no local work to do.\n\nThis feature is currently experimental and may change in the future. (Default: false)"
          }
        },
        "ProofShareMaxTasks": {
          "type": "integer",
          "options": {
            "infoText": "The maximum amount of ProofShare tasks that can run simultaneously. Note that the maximum number of tasks will\nalso be bounded by resources available on the machine. (Default: 0 - unlimited)"
          }
        },
        "EnableRemoteProofs": {
          "type": "boolean",
          "options": {
            "infoText": "EnableRemoteProofs enables the remote proof tasks on the node. Local snark tasks will be transformed into remote\nproving tasks when this option is enabled. Details on which SP IDs are allowed to request remote proofs are managed\nvia Client Settings on the Proofshare webui page. Buy delay can also be set in the Client Settings page. (Default: false)"
          }
        },
        "RemoteProofMaxUploads": {
          "type": "integer",
          "options": {
            "infoText": "The maximum number of remote proofs that can be uploaded simultaneously by each node. (Default: 15)"
          }
        },
        "EnableWalletExporter": {
          "type": "boolean",
          "options": {
            "infoText": "EnableWalletExporter enables the wallet exporter on the node. This will export wallet stats to prometheus.\nNOTE: THIS MUST BE ENABLED ONLY ON A SINGLE NODE IN THE CLUSTER TO BE USEFUL (Default: false)"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "HTTPConfig": {
      "properties": {
        "Enable": {
          "type": "boolean",
          "options": { "infoText": "Enable the HTTP server on the node" }
        },
        "DomainName": {
          "type": "string",
          "options": {
            "infoText": "DomainName specifies the domain name that the server uses to serve HTTP requests. DomainName cannot be empty and cannot be\nan IP address"
          }
        },
        "ListenAddress": {
          "type": "string",
          "options": {
            "infoText": "ListenAddress is the address that the server listens for HTTP requests. It should be in form \"x.x.x.x:1234\" (Default: 0.0.0.0:12310)"
          }
        },
        "DelegateTLS": {
          "type": "boolean",
          "options": {
            "infoText": "DelegateTLS allows the server to delegate TLS to a reverse proxy. When enabled the listen address will serve\nHTTP and the reverse proxy will handle TLS termination."
          }
        },
        "ReadTimeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "ReadTimeout is the maximum duration for reading the entire or next request, including body, from the client.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"5m0s\")"
          }
        },
        "IdleTimeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "IdleTimeout is the maximum duration of an idle session. If set, idle connections are closed after this duration.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"5m0s\")"
          }
        },
        "ReadHeaderTimeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "ReadHeaderTimeout is amount of time allowed to read request headers\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"5m0s\")"
          }
        },
        "CORSOrigins": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "CORSOrigins specifies the allowed origins for CORS requests to the Curio admin UI. If empty, CORS is disabled.\nIf not empty, only the specified origins will be allowed for CORS requests.\nThis is required for third-party UI servers.\n\"*\" allows everyone, it's best to specify the UI servers' hostname."
          }
        },
        "CSP": {
          "type": "string",
          "options": {
            "infoText": "CSP sets the Content Security Policy for content served via the /piece/ retrieval endpoint.\nValid values: \"off\", \"self\", \"inline\" (Default: \"inline\")\n\nSince storage providers serve user-uploaded content on their domain, CSP helps control\nwhat these files can do when rendered in browsers. Choose based on your use case:\n\n- \"off\": No CSP headers. Content can load any external resources and execute any scripts.\nUse only if you fully trust all stored content or need maximum compatibility.\n\n- \"self\": Restricts content to only load resources from your domain. Prevents external\nresource loading but allows stored HTML/JS/CSS to interact with each other.\nGood for semi-trusted content that needs internal functionality.\n\n- \"inline\": (Default) Allows inline scripts/styles and same-origin resources. Provides\nbasic protection while maintaining compatibility with most web content.\nSuitable for general-purpose content hosting.\n\nNote: Stricter policies may prevent some HTML content from displaying as intended.\nConsider the trust level of your users and whether you need to support interactive content."
          }
        },
        "CompressionLevels": {
          "$ref": "#/$defs/CompressionConfig",
          "options": {
            "infoText": "CompressionLevels hold the compression level for various compression methods supported by the server"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Header": {
      "additionalProperties": {
        "items": { "type": "string" },
        "type": "array"
      },
      "type": "object"
    },
    "IPNIConfig": {
      "properties": {
        "Disable": {
          "type": "boolean",
          "options": {
            "infoText": "Disable set whether to disable indexing announcement to the network and expose endpoints that\nallow indexer nodes to process announcements. Default: False"
          }
        },
        "ServiceURL": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "The network indexer web UI URL for viewing published announcements"
          }
        },
        "DirectAnnounceURLs": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "The list of URLs of indexing nodes to announce to. This is a list of hosts we talk to tell them about new\nheads."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "IndexingConfig": {
      "properties": {
        "InsertBatchSize": {
          "type": "integer",
          "options": { "infoText": "Number of records per insert batch" }
        },
        "InsertConcurrency": {
          "type": "integer",
          "options": {
            "infoText": "Number of concurrent inserts to split AddIndex calls to"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MK12CollateralConfig": {
      "properties": {
        "DealCollateralWallet": {
          "type": "string",
          "options": {
            "infoText": "DealCollateralWallet is the wallet used to add balance to Miner's market balance. This balance is\nutilized for deal collateral in market (f05) deals."
          }
        },
        "CollateralLowThreshold": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "CollateralLowThreshold is the balance below which more balance will be added to miner's market balance\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"5 FIL\")"
          }
        },
        "CollateralHighThreshold": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "CollateralHighThreshold is the target balance to which the miner's market balance will be topped up\nwhen it drops below CollateralLowThreshold.\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"20 FIL\")"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MK12Config": {
      "properties": {
        "PublishMsgPeriod": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "When a deal is ready to publish, the amount of time to wait for more\ndeals to be ready to publish before publishing them all as a batch\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"5m0s\")"
          }
        },
        "MaxDealsPerPublishMsg": {
          "type": "integer",
          "options": {
            "infoText": "The maximum number of deals to include in a single PublishStorageDeals\nmessage (Default: 8)"
          }
        },
        "MaxPublishDealFee": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "The maximum fee to pay per deal when sending the PublishStorageDeals message\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"0.5 FIL\")"
          }
        },
        "ExpectedPoRepSealDuration": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "ExpectedPoRepSealDuration is the expected time it would take to seal the deal sector\nThis will be used to fail the deals which cannot be sealed on time.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"8h0m0s\")"
          }
        },
        "ExpectedSnapSealDuration": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "ExpectedSnapSealDuration is the expected time it would take to snap the deal sector\nThis will be used to fail the deals which cannot be sealed on time.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"2h0m0s\")"
          }
        },
        "SkipCommP": {
          "type": "boolean",
          "options": {
            "infoText": "SkipCommP can be used to skip doing a commP check before PublishDealMessage is sent on chain\nWarning: If this check is skipped and there is a commP mismatch, all deals in the\nsector will need to be sent again (Default: false)"
          }
        },
        "DisabledMiners": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "DisabledMiners is a list of miner addresses that should be excluded from online deal making protocols"
          }
        },
        "MaxConcurrentDealSizeGiB": {
          "type": "integer",
          "options": {
            "infoText": "MaxConcurrentDealSizeGiB is a sum of all size of all deals which are waiting to be added to a sector\nWhen the cumulative size of all deals in process reaches this number, new deals will be rejected.\n(Default: 0 = unlimited)"
          }
        },
        "DenyUnknownClients": {
          "type": "boolean",
          "options": {
            "infoText": "DenyUnknownClients determines the default behaviour for the deal of clients which are not in allow/deny list\nIf True then all deals coming from unknown clients will be rejected. (Default: false)"
          }
        },
        "DenyOnlineDeals": {
          "type": "boolean",
          "options": {
            "infoText": "DenyOnlineDeals determines if the storage provider will accept online deals (Default: false)"
          }
        },
        "DenyOfflineDeals": {
          "type": "boolean",
          "options": {
            "infoText": "DenyOfflineDeals determines if the storage provider will accept offline deals (Default: false)"
          }
        },
        "CIDGravityTokens": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "CIDGravityTokens is the list of authorization token to use for CIDGravity filters. These should be in format\n\"minerID1:Token1\", \"minerID2:Token2\". If a token for a minerID within the cluster is not provided,\nCIDGravity filters will not be applied to deals associated with that miner ID."
          }
        },
        "DefaultCIDGravityAccept": {
          "type": "boolean",
          "options": {
            "infoText": "DefaultCIDGravityAccept when set to true till accept deals when CIDGravity service is not available.\nDefault behaviors is to reject the deals (Default: false)"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MK20Config": {
      "properties": {
        "ExpectedPoRepSealDuration": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "ExpectedPoRepSealDuration is the expected time it would take to seal the deal sector\nThis will be used to fail the deals which cannot be sealed on time.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"8h0m0s\")"
          }
        },
        "ExpectedSnapSealDuration": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "ExpectedSnapSealDuration is the expected time it would take to snap the deal sector\nThis will be used to fail the deals which cannot be sealed on time.\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"2h0m0s\")"
          }
        },
        "SkipCommP": {
          "type": "boolean",
          "options": {
            "infoText": "SkipCommP can be used to skip doing a commP check before PublishDealMessage is sent on chain\nWarning: If this check is skipped and there is a commP mismatch, all deals in the\nsector will need to be sent again (Default: false)"
          }
        },
        "DisabledMiners": {
          "items": { "type": "string" },
          "type": "array",
          "options": {
            "infoText": "DisabledMiners is a list of miner addresses that should be excluded from online deal making protocols"
          }
        },
        "MaxConcurrentDealSizeGiB": {
          "type": "integer",
          "options": {
            "infoText": "MaxConcurrentDealSizeGiB is a sum of all size of all deals which are waiting to be added to a sector\nWhen the cumulative size of all deals in process reaches this number, new deals will be rejected.\n(Default: 0 = unlimited)"
          }
        },
        "DenyUnknownClients": {
          "type": "boolean",
          "options": {
            "infoText": "DenyUnknownClients determines the default behaviour for the deal of clients which are not in allow/deny list\nIf True then all deals coming from unknown clients will be rejected. (Default: false)"
          }
        },
        "MaxParallelChunkUploads": {
          "type": "integer",
          "options": {
            "infoText": "MaxParallelChunkUploads defines the maximum number of upload operations that can run in parallel. (Default: 512)"
          }
        },
        "MinimumChunkSize": {
          "type": "integer",
          "options": {
            "infoText": "MinimumChunkSize defines the smallest size of a chunk allowed for processing, expressed in bytes. Must be a power of 2. (Default: 16 MiB)"
          }
        },
        "MaximumChunkSize": {
          "type": "integer",
          "options": {
            "infoText": "MaximumChunkSize defines the maximum size of a chunk allowed for processing, expressed in bytes. Must be a power of 2. (Default: 256 MiB)"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "MarketConfig": {
      "properties": {
        "StorageMarketConfig": {
          "$ref": "#/$defs/StorageMarketConfig",
          "options": {
            "infoText": "StorageMarketConfig houses all the deal related market configuration"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PagerDutyConfig": {
      "properties": {
        "Enable": {
          "type": "boolean",
          "options": {
            "infoText": "Enable is a flag to enable or disable the PagerDuty integration."
          }
        },
        "PagerDutyEventURL": {
          "type": "string",
          "options": {
            "infoText": "PagerDutyEventURL is URL for PagerDuty.com Events API v2 URL. Events sent to this API URL are ultimately\nrouted to a PagerDuty.com service and processed.\nThe default is sufficient for integration with the stock commercial PagerDuty.com company's service."
          }
        },
        "PageDutyIntegrationKey": {
          "type": "string",
          "options": {
            "infoText": "PageDutyIntegrationKey is the integration key for a PagerDuty.com service. You can find this unique service\nidentifier in the integration page for the service."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PieceLocatorConfig": {
      "properties": {
        "URL": { "type": "string" },
        "Headers": { "$ref": "#/$defs/Header" }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PreCommitBatchingConfig": {
      "properties": {
        "BaseFeeThreshold": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "Base fee value below which we should try to send Precommit messages immediately\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"0.005 FIL\")"
          }
        },
        "Timeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Maximum amount of time any given sector in the batch can wait for the batch to accumulate\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"4h0m0s\")"
          }
        },
        "Slack": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Time buffer for forceful batch submission before sectors/deal in batch would start expiring\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"6h0m0s\")"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "PrometheusAlertManagerConfig": {
      "properties": {
        "Enable": {
          "type": "boolean",
          "options": {
            "infoText": "Enable is a flag to enable or disable the Prometheus AlertManager integration."
          }
        },
        "AlertManagerURL": {
          "type": "string",
          "options": {
            "infoText": "AlertManagerURL is the URL for the Prometheus AlertManager API v2 URL."
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "SlackWebhookConfig": {
      "properties": {
        "Enable": {
          "type": "boolean",
          "options": {
            "infoText": "Enable is a flag to enable or disable the Prometheus AlertManager integration."
          }
        },
        "WebHookURL": {
          "type": "string",
          "options": {
            "infoText": "WebHookURL is the URL for the URL for slack Webhook.\nExample: https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "StorageMarketConfig": {
      "properties": {
        "MK12": {
          "$ref": "#/$defs/MK12Config",
          "options": {
            "infoText": "MK12 encompasses all configuration related to deal protocol mk1.2.0 and mk1.2.1 (i.e. Boost deals)"
          }
        },
        "MK20": {
          "$ref": "#/$defs/MK20Config",
          "options": {
            "infoText": "MK20 encompasses all configuration related to deal protocol mk2.0 i.e. market 2.0"
          }
        },
        "IPNI": {
          "$ref": "#/$defs/IPNIConfig",
          "options": { "infoText": "IPNI configuration for ipni-provider" }
        },
        "Indexing": {
          "$ref": "#/$defs/IndexingConfig",
          "options": { "infoText": "Indexing configuration for deal indexing" }
        },
        "PieceLocator": {
          "items": { "$ref": "#/$defs/PieceLocatorConfig" },
          "type": "array",
          "options": {
            "infoText": "PieceLocator is a list of HTTP url and headers combination to query for a piece for offline deals\nUser can run a remote file server which can host all the pieces over the HTTP and supply a reader when requested.\nThe server must support \"HEAD\" request and \"GET\" request.\n1. \u003cURL\u003e?id=pieceCID with \"HEAD\" request responds with 200 if found or 404 if not. Must send header \"Content-Length\" with file size as value\n2. \u003cURL\u003e?id=pieceCID must provide a reader for the requested piece along with header \"Content-Length\" with file size as value"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "UpdateBatchingConfig": {
      "properties": {
        "BaseFeeThreshold": {
          "type": "string",
          "pattern": "1 fil/0.03 fil/0.31/1 attofil",
          "options": {
            "infoText": "Base fee value below which we should try to send Commit messages immediately\nAccepts a decimal string (e.g., \"123.45\" or \"123 fil\") with optional \"fil\" or \"attofil\" suffix. (Default: \"0.005 FIL\")"
          }
        },
        "Timeout": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Maximum amount of time any given sector in the batch can wait for the batch to accumulate\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"1h0m0s\")"
          }
        },
        "Slack": {
          "type": "string",
          "pattern": "0h0m0s",
          "options": {
            "infoText": "Time buffer for forceful batch submission before sectors/deals in batch would start expiring\nTime duration string (e.g., \"1h2m3s\") in TOML format. (Default: \"1h0m0s\")"
          }
        }
      },
      "additionalProperties": false,
      "type": "object"
    }
  }
}
